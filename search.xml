<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js判断一个变量是对象还是数组的实用方法记录]]></title>
    <url>%2F2019%2F03%2F14%2Fjs%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在实际开发中，经常需要检测一个变量的类型，是字符串、数字、布尔还是对象、数组？还是null、undefined？ 对于字符串和数字、布尔这种基本类型，用typeof()来检测就足够了，但是typeof用在数组和对象、null之间就不灵了。由图中可以看出，变量为null，数组，对象的abc使用typeof检测出来的都是object，没有办法进一步区分。 使用constructor检测 1234var arr=[1,2];var obj=&#123;&#125;;console.log(arr.constructor === Array) //trueconsole.log(obj.constructor === Array) //false 使用instanceof1234 var arr=[1,2]; var obj=&#123;&#125;; console.log(arr instanceof Array); //trueconsole.log(obj instanceof Array); //false constructor和instanceof 在iframe下使用时会失效，每个iframe都有一套环境，都有一个window，不共享原型链。 下面的代码取自网络123456var iframe = document.createElement(&apos;iframe&apos;); //创建iframedocument.body.appendChild(iframe); //添加到body中xArray = window.frames[window.frames.length-1].Array;var arr = new xArray(1,2,3); // 声明数组[1,2,3]alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false 为什么会出现这样的情况呢？原因就是：在当前窗口引入框架，其实就是引入了window对象，当我们在遍历iframe框架里的变量时使用arr instanceof Array 或者arr.constructor === Array，要注意这个Array是当前window对象的Array，而不是构造出arr的iframe里的window，所以会返回false。 使用toString方法1234 var arr=[1,2]; var obj=&#123;&#125;; console.log(Object.prototype.toString.call(arr)); // &quot;[object Array]&quot;console.log(Object.prototype.toString.call(obj)); // &quot;[object Object]&quot; 使用Array.isArray()ECMAScript5将Array.isArray()正式引入JavaScript，目的就是准确地检测一个值是否为数组。IE9+、 Firefox 4+、Safari 5+、Opera 10.5+和 Chrome都实现了这个方法。但是在IE8之前的版本是不支持的。 综合上述方法，自己封装一个函数1234567891011121314var arr = [];var arr2 = &#123;&#125;;function isArrayFn(value)&#123; if (typeof Array.isArray === &quot;function&quot;) &#123; //先检测是否有isArray方法 return Array.isArray(value); &#125;else&#123; //不支持isArray方法，则使用toString方法 return Object.prototype.toString.call(value) === &quot;[object Array]&quot;; //如果是对象则是&quot;[object Object]&quot; &#125;&#125;console.log(isArrayFn(arr)); // trueconsole.log(isArrayFn(arr2)); // false]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo+github搭建个人博客]]></title>
    <url>%2F2019%2F02%2F27%2F%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[用hexo+github page快速搭建个人静态博客1.hexo环境搭建首先需要电脑安装好了nodejs（具体安装步骤略过），还需要有github账号。打开cmd命令行，全局安装hexo npm install -g hexo-cli 可以使用 hexo v 来检查是否安装成功。接下来使用hexo cli来创建项目：使用hexo init 就会在当前文件夹下创建了项目，当然也可以使用hexo init 文件夹名称 来创建文件夹的同时创建项目。接着运行 npm install安装依赖，注意，安装hexo的文件夹需要是空文件夹。 2.hexo的基本使用及常见的命令hexo s 使用这个命令可以在本地跑起来，可以看到cmd窗口提示项目运行在 http://localhost:4000，打开浏览器输入提示的地址即可访问了，不过可以看到，默认的主题有点丑，我们可以换一个，在这里我们换next这个简洁的主题。我们可以直接百度搜索hexo next主题官网或者去hexo官网找next主题都可以，我们找到next的github，克隆下来，放到博客项目的themes目录下，接下来打开根目录的配置文件_config.yml文件找到 theme，把默认的该为next，然后命令行hexo clean &amp;&amp; hexo s刷新页面即可成功替换主题了。快速创建文章命令为 hexo new &quot;文章名字&quot; 执行完这个命令后就会在sources下的_posts目录下创建名称为 刚刚创建的同名md文件，可以用编辑器直接打开编辑了。 这里需要注意：在next主题的配置文件下添加了菜单后，点击了提示找不到页面，不要慌，是因为默认只生产home和Archive页面，需要自己创建相应的页面，比如about页面 hexo new page &quot;about&quot; 这时 source里面多了个目录about，里面有个index.md，就可以正常访问了，内容就在那个index.md里添加与github对接在github上新建一个名为xxx.github.io 的仓库，然后在hexo的_config.yml中的 1234deploy: type: git repository: git@github.com:hongyu2016/hongyu2016.github.io.git branch: master 填写相应的git地址，然后需要把本地项目与git仓库相关联起来，需要使用ssh来连接，git ssh连接请参考 配置git ssh 。在本地仓库与远程仓库连接的过程中可能会出现分支不匹配等错误，需要具体问题然后再进行针对性解决。本地仓库与远程仓库关联上后就可以在本地进行发布了，hexo d为发布命令，会将项目发布到github page，发布成功后，会在本地生成的静态文件推送到到github，其他文件是不会推送的，这个时候会把原本在github上的readme文件删除，不要慌，在resoures下新建readme文件再次发布就好了，注意：千万不要使用github的git push发布，这样发布是没有效果的，github会在每次push时发编译失败的邮件给你，因为github page只支持静态文件，所以只能使用hexo d命令，另外在发布前最好先hexo clean &amp;&amp; hexo g先清除和重新生成静态文件发发布。发布成功后，输入xxx.github.io就可以正常访问博客了。 结语：搭建hexo博客还是比较简单的，个人觉得在推送到github的过程中比较麻烦，容易出各种问题，这个地方需要注意。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署在github page的hexo博客绑定二级域名]]></title>
    <url>%2F2019%2F02%2F26%2F%E9%83%A8%E7%BD%B2%E5%9C%A8github-page%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前提：已经有了域名（这里以阿里云为例）以及能成功访问的github page（这里以hexo部署的博客为例）。1.增加域名解析：这里需要注意，记录类型需要选择CNAME，主机记录为除www和@外的字符，因为我要用blog作为二级域名，所以写blog。解析线路选默认就好了，一开始我选境外，结果不行。记录值为***.github.io(即你的github page地址)。到这里解析设置完成了。 2.增加域名解析：在GitHub博客仓库的根目录中新建文件CNAME （没有后缀），里面填写 blog.iyuge.cn 注意，因为hexo在部署至github时会重新删除github的文件，所以我们必须在本地的source目录下新建CNAME文件，然后hexo clean &amp;&amp; hexo g &amp;&amp; hexo d github上就有CNAME文件了 结语：至此，给github page绑定二级域名就完成了，很简单，但是需要注意的是第一次有可能不成功需要重试几次，每次可能需要等一段时间才会生效！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
